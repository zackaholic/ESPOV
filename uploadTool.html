<!DOCTYPE HTML>
<html>
  <head>

  </head>
  <body id="page">
    <canvas id="myCanvas" width="900" height="600" style="touch-action: none; border:1px solid; background-color: #000000"></canvas>
    <p></p>
    <div id="uploadButton">
     <h3>Upload</h3> 
    </div>
    <div id="colorPicker">
      <div id="drawingColorSwatch">
      </div>
      <div id="colorsInUse">
      </div>
      <table id="palette">
      </table>
      </div>
    </div>
    <style>
      #page {
        width: 900px;
        height: 800px;
      }
      #uploadButton {
        position: relative;
        cursor: pointer;
        border: 1px solid;
        background-color: #b3e7ff;
        width: 100px;
        height: 50px;
        display: inline-block;
        font-family:Arial; 
        text-align:center;
        border-radius: 4px;
      }
      #uploadButton h3 {
        position: absolute;
        top: 50%;
        margin: 0px;
        left: 50%;
        margin-right: 50%;
        transform: translate(-50%, -50%);
     }
      #colorPicker {
        touch-action: none; 
        display: inline-block; 
        float:right; 
        border:1px solid;
      }
      #drawingColorSwatch {
        width:130px; 
        height:50px; 
        display:inline-block; 
        float:left; 
        border:1px solid;
        margin: 2px;
      }
      #colorsInUse {
        width: 130px;
        height: 130px;
        border:1px solid;
        margin: 2px;
        float: left;
        clear: left;
      }
      #palette {
        width: 500px;
        position: relative;
      }
    </style>
    <script type="text/javascript" defer>
      var canvas = document.getElementById('myCanvas');
      var colorPicker = document.getElementById('colorPicker')

      function Pixels(rows, cols, canvas) {
        var buffer = new Uint8Array(rows * cols);
        var canvas = canvas;
        var ctx = canvas.getContext('2d');
        var pixelSize = 30;
        var canvasRows = rows;
        var canvasColumns = cols;
        var drawing;
        var drawColor;

        this.setDrawColor = function(color) {
          drawColor = color;
          ctx.fillStyle = color;
        }

        this.outputHexString = function() {
          var hexString = '';
          for (var i = 0; i < buffer.length; i++) {
            hexString += padHex(buffer[i]);
          }
          return hexString;
        }

        this.getPixel = function(row, col) {
          var p = row + col * canvasRows;
          return buffer[p];
        }

        this.inputHexString = function(hexString) {
          //some color shifting happens during the import. This is kind of a mess.
          var hex = hexString;
          var value;
          for (var i = 0; i < buffer.length; i++) {
            value = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
            buffer[i] = value;
          }
          redrawCanvasFromBuffer();
        }

        function redrawCanvasFromBuffer() {
          var row, col, colorString, r, g, b;
          for (var i = 0; i < buffer.length; i++) {
            col = Math.floor(i / canvasRows);
            row = i % canvasRows;

            r = buffer[i] & 0b11100000;
            g = (buffer[i] & 0b00011100) << 3;
            b = (buffer[i] & 0b00000011) << 6;
            colorString = '#' + padHex(r) + padHex(g) + padHex(b);
            Pixels.setDrawColor(colorString);
            setPixel(row, col);
          }
        }

        function setPixel(row, col) {
          var p = row + col * canvasRows;
          buffer[p] = color24To8Bit(drawColor);
          ctx.fillRect(col * pixelSize, row * pixelSize, pixelSize, pixelSize);     
        }

        function handleMove(evt) {
          if (drawing) {
            var row, col, mouse;
            mouse = getMousePos(canvas, evt);

            col = Math.floor(mouse.x / pixelSize);
            row = Math.floor(mouse.y / pixelSize);

            setPixel(row, col);
          }
        }

        function handleMouseUp(evt) {
          drawing = false;
        }

        function handleMouseDown(evt) {
          var row, col;
          var mouse = getMousePos(canvas, evt);

          col = Math.floor(mouse.x / pixelSize);
          row = Math.floor(mouse.y / pixelSize);

          drawing = true;

          setPixel(row, col);
        }

        canvas.addEventListener("mousemove", handleMove);
        canvas.addEventListener("mousedown", handleMouseDown, false);
        canvas.addEventListener("mouseup", handleMouseUp);
        canvas.addEventListener("touchmove", handleMove);
        canvas.addEventListener("touchstart", handleMouseDown);
        canvas.addEventListener("touchend", handleMouseUp);                
      }

      function ColorPicker(numColors, picker) {
        //TODO: try an indexed color palette suitable for actual LED values
        //also gamma correction??
        var inUse = [];
        var picker = picker;
        var palette = document.getElementById("palette");
        var inUsePalette = document.getElementById("colorsInUse")
        var setBorder = createBorderPatrol();

        function createBorderPatrol() {
          var lastElements;
          var currentElements;
          var picker = document.getElementById("colorPicker");

          var setBorder = function(color) {
            if (this.currentElements) {
              this.lastElements = this.currentElements;
              if (this.lastElements.item(0)){
                this.lastElements.item(0).style.borderColor = this.lastElements.item(0).className;
              }
              if (this.lastElements.item(1)){
                this.lastElements.item(1).style.borderColor = this.lastElements.item(0).className;
              }
            }
            this.currentElements = document.getElementsByClassName(color);
            if (this.currentElements.item(0)){
              this.currentElements.item(0).style.borderColor = "#000000";
            }
            if (this.currentElements.item(1)){
              this.currentElements.item(1).style.borderColor = "#000000";
            }

          }
          return setBorder;
        }

        function displayDrawColor(color) {
          document.getElementById("drawingColorSwatch").style.backgroundColor = color;
        }

        function updateColorsInUse(color) {
          if (inUse.includes(color) || inUse.length == 25) {
            return;
          }
          var usePalette = document.getElementById("colorsInUse");
          var e = document.createElement("div");
          usePalette.appendChild(e);
          e.className = color;
          e.setAttribute("style", "margin: 1px; border: 2px solid #000000; padding: 0px; width: 20px; height: 20px; background-color: " + color +
            "; display: inline-block; vertical-align: top");
          e.addEventListener("mousedown", pickerMouseDown);
          e.addEventListener("mouseenter", pickerMouseOver);
          inUse.push(color);

        }

        function populateColorPalette() {
          var index = 0;
          var row;

          for (var r = 0; r < 255; r+= 36) {
            for (var g = 0; g < 255; g+= 36) {
              for (var b = 0; b < 255; b+= 85) {
                var color = '#' + padHex(r) + padHex(g) + padHex(b);
                var e;
                if (index % 24 == 0){
                  row = document.createElement("tr");
                  palette.appendChild(row);
                  e = document.createElement("td");
                  row.appendChild(e);
                  e.className = color;
                  e.setAttribute("style", "margin: 0px; border: 2px solid " + color + "; padding: 0px; width: 20px; height: 20px; background-color: " + color);
                  e.addEventListener("mousedown", pickerMouseDown);
                  e.addEventListener("mouseenter", pickerMouseOver);
                  //check out MouseEvent.region()(returns id of hit region)
                  //support undo/erase with MouseEvent.which()(returns button pressed)?
                  index++;
                } else {
                  e = document.createElement("td");
                  row.appendChild(e);
                  e.className = color;
                  e.setAttribute("style", "margin: 0px; border: 2px solid " + color + "; padding: 0px; width: 20px; height: 20px; background-color: " + color);
                  e.addEventListener("mousedown", pickerMouseDown);
                  e.addEventListener("mouseenter", pickerMouseOver);
                  index++;
                }
              }
            }
          }        
        }

        function pickerMouseDown(evt) {
          eraseSelected = false;
          drawSelected = true;
          drawColor = evt.srcElement.className;
          Pixels.setDrawColor(drawColor);
          displayDrawColor(drawColor);
          setBorder(evt.srcElement.className);
          updateColorsInUse(drawColor);
        }
        function pickerMouseOver(evt) {
          displayDrawColor(evt.srcElement.className);
        }

        document.getElementById("palette").addEventListener("mouseleave", function(evt) {
          displayDrawColor(drawColor);
        });

        populateColorPalette();                

      }

      function uploadPixels(pixelArray) {
        var httpRequest = new XMLHttpRequest();
        httpRequest.onreadystatechange = function() {
          if (httpRequest.readyState === XMLHttpRequest.DONE) {
            if (httpRequest.status === 200) {
              //console.log(httpRequest.responseText);
            } else {
              //console.log('There was a problem with the request.');
            }
          }
        }; 
        // console.log(Pixels.outputHexString());
        httpRequest.open('POST', 'upload');
        httpRequest.send('rows=20&cols=30&pixels=' + Pixels.outputHexString());

      };

      function getMousePos(element, evt) {
        var rect = element.getBoundingClientRect();
        var xPos, yPos;
        //hacky way to handle touchscreens - this check might not work across browsers?
        if (evt.clientX) {
          xPos = evt.clientX;
          yPos = evt.clientY;
        } else {
          xPos = evt.touches[0].clientX;
          yPos = evt.touches[0].clientY;
        }
        xPos -= rect.left;
        yPos -= rect.top;
        return {x : xPos, y : yPos};
      }

      function padHex(num) {
        var paddedNum = num.toString(16);
        if (paddedNum.length == 1) {
          return '0' + paddedNum;
        }
        return paddedNum;
      }

      function color8to24bit(color) {
        var red = color & 0b11100000 << 21;
        var green = color & 0b00011100 << 13;
        var blue = color & 0b00000011 << 6;
        var color24 = red | green | blue;
        return color24;
      }

      function color24To8Bit(color) {
        if (typeof color === 'string') {
          var color = parseInt(color.replace(/^#/, ''), 16);
        }
        var red = color >> 21;
        var green = color >> 13 & 0x07;
        var blue = color >> 6 & 0x03;
        var color8 = (red << 5) | (green << 2) | blue;
        return color8;
      }

      var Pixels = new Pixels(10, 30, canvas);
      var Picker = new ColorPicker(256, colorPicker);

      document.getElementById("uploadButton").onclick = function() {
        uploadPixels();
      };
    </script>
  </body>
</html>




